/* Generated from orogen/lib/orogen/templates/tasks/Task.hpp */

#ifndef USV_CAMERA_SIMULATION_TASK_TASK_HPP
#define USV_CAMERA_SIMULATION_TASK_TASK_HPP

#include "usv_camera_simulation/TaskBase.hpp"
#include <gps_base/UTMConverter.hpp>

namespace usv_camera_simulation {
    /*! \class Task
     */
    class Task : public TaskBase {
        /** The base class is auto-generated by orogen to define the task's interface
         *
         * It is located in the .orogen/tasks folder
         */
        friend class TaskBase;

        struct Info {
            ais_base::Position ais_position;
            ais_base::VesselInformation ais_info;
            std::string frame_id;
        };
        std::map<uint32_t, Info> mInfo;

        struct Definition : ModelDefinition {
            sdf::ElementPtr parsed_sdf;

            explicit Definition(ModelDefinition const& d)
                : ModelDefinition(d)
            {
            }
        };
        std::vector<Definition> mDefinitions;

        std::unique_ptr<gps_base::UTMConverter> mUTM;
        void addVesselInformation(ais_base::VesselInformation const& info);
        void updateVesselPosition(ais_base::Position const& position);
        std::string createVessel(Info const& info);

    protected:
    public:
        /** TaskContext constructor for Task
         * \param name Name of the task. This name needs to be unique to make
         *             it identifiable via nameservices.
         * \param initial_state The initial TaskState of the TaskContext.
         *                      This is deprecated. It should always be the
         *                      configure state.
         */
        Task(std::string const& name = "usv_camera_simulation::Task");

        ~Task();

        /**
         * Hook called when the state machine transitions from PreOperational to
         * Stopped.
         *
         * If the code throws an exception, the transition will be aborted
         * and the component will end in the EXCEPTION state instead
         *
         * @return true if the transition can continue, false otherwise
         */
        bool configureHook();

        /**
         * Hook called when the state machine transition from Stopped to Running
         *
         * If the code throws an exception, the transition will be aborted
         * and the component will end in the EXCEPTION state instead
         *
         * @return true if the transition is successful, false otherwise
         */
        bool startHook();

        void updateUI();

        /**
         * Hook called in the RuntimeError state, under the same conditions than
         * the updateHook
         *
         * Call recover() to go back in the Runtime state.
         */
        void errorHook();

        /**
         * Hook called when the component transitions out of the Running state
         *
         * This is called for any transition out of running, that is the
         * transitions to Stopped, Exception and Fatal
         */
        void stopHook();

        /**
         * Hook called on all transitions to PreOperational
         *
         * This is called for all transitions into PreOperational, that is
         * either from Stopped or Exception
         */
        void cleanupHook();
    };
}

#endif
